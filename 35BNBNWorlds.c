#pragma config(UserModel, "C:/Users/rstudent/code/robot-configs/35B.c")
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)//Platform Type
#pragma competitionControl(Competition) //This is a Competition Template
#pragma autonomousDuration(15) //15 second autonomous mode
#pragma userControlDuration(105) //1:45 driver control mode
#include "Vex_Competition_Includes.c" //Uses Vex stuff
#define POWER_EXPANDER_A1
#include <CKFlywheelSpeedController.h>

////////////////////////////////
//Global Variable Declarations//
////////////////////////////////

float speed = 0; //Speed of the output shaft of Flywheel motors in radians per second
bool isFlywheelOn = false;
FlywheelSpeedController controller;

/////////////////////////////////////////////////////////
//Pre-Autonomous Functions - Initializes most variables//
/////////////////////////////////////////////////////////

void pre_auton()
{
	bStopTasksBetweenModes = true;
	//bLCDBacklight = true;
	//clearLCDLine(0);
	//clearLCDLine(1);

	tMotor motorPorts[] = { flyFour, flyOneYThree, flyTwo };
	FlywheelSpeedControllerInit( controller, 0.1, 0.03, 0.0, 1.2889, 0.0925, motorPorts, 3, M393HighSpeed );

	speed = 0;

	////Completely clear out any previous sensor readings by setting the port to "sensorNone"
	//SensorType[gyro] = sensorNone;
	//delay(1000);
	////Reconfigure Analog Port as a Gyro sensor and allow time for ROBOTC to calibrate it
	//SensorType[gyro] = sensorGyro;
	//delay(2000);
}

//////////////////////////////////////////////////////////
//Define Functions Needed for Operator Control and Auton//
//////////////////////////////////////////////////////////

////Calculates the number of ticks in one inch of travel based on wheel size
//const float wheelDiameter = 10.4;//cm

//int ticksForInches(float inches)
//{
//	return(int)round(inches*360.0/(wheelDiameter*PI/2.54));
//}
////const float WheelbaseWidth = 34;//cm
////const float WheelbaseLength = 31;//cm
////const float WheelbaseRadius = sqrt(WheelbaseLength*WheelbaseLength + WheelbaseWidth*WheelbaseWidth)/2;

////Sets Left Drive Train Motors to a power
//void setLeftDriveTrainPower(int power)
//{
//	power = bound(power, -127, 127);
//	//motor[leftFront] = power;
//	//motor[leftBack] = power;
//}

////Sets Right Drive Train Motors to a power
//void setRightDriveTrainPower(int power)
//{
//	power = bound(power, -127, 127);
//	//motor[rightDrive] = power;
//}

//int readEncoder(int port){
//	int v = SensorValue[port];
//	return v;
//}

////Takes distanceToDrive (in inches), drives that distance
//void driveADistance(float distanceToDrive)
//{
//	string dispStr;
//	SensorValue[leftEncoders] = 0;
//	SensorValue[rightEncoders] = 0;
//	int error = 0;
//	int leftDriven = 0;
//	int rightDriven = 0;
//	int goalDistance = ticksForInches(distanceToDrive);
//	float Kp = 1.0;
//	bool isLeftDone = leftDriven > goalDistance;
//	bool isRightDone = rightDriven > goalDistance;
//	int basePower = 100;
//	while (!isLeftDone || !isRightDone)
//	{
//		leftDriven = readEncoder(leftEncoders);
//		rightDriven = -readEncoder(rightEncoders);
//		sprintf(dispStr, "%d  %d", leftDriven, rightDriven);
//		clearLCDLine(0);
//		displayLCDString(0,0,dispStr);
//		error = leftDriven - rightDriven; //+ if left has gone further, - if right has gone further
//		isLeftDone = leftDriven > goalDistance;
//		isRightDone = rightDriven > goalDistance;
//		int offset = (int)round(Kp * error);
//		offset = bound(offset, -20, 20);
//		setLeftDriveTrainPower( isLeftDone ? 0 : basePower - offset) ;
//		setRightDriveTrainPower( isRightDone ? 0 :   basePower - offset)  ;
//		delay(100);
//	}
//	setLeftDriveTrainPower(0);
//	setRightDriveTrainPower(0);
//}
//void printGyro()
//{
//	string toDisp;
//	SensorValue[gyro] = 0;
//	int gyroValue = SensorValue[gyro];
//	while(true){
//		gyroValue = SensorValue[gyro];
//		sprintf(toDisp, "Gyro: %d", gyroValue);
//		clearLCDLine(0);
//		displayLCDString(0,0,toDisp);
//		delay(300);
//	}

//}
////500 = 90 deg
//void turnaDistance(int deciDegreesToTurn)
//{
//	SensorValue[gyro] = 0;
//	int gyroValue = SensorValue[gyro];
//	int basePower = 75;
//	if(deciDegreesToTurn < 0){
//		setLeftDriveTrainPower(basePower);
//		setRightDriveTrainPower(-basePower);
//		while (-gyroValue < -deciDegreesToTurn)
//		{
//			gyroValue = SensorValue[gyro];
//			delay(30);
//		}
//	}
//	else
//	{
//		setLeftDriveTrainPower(-basePower);
//		setRightDriveTrainPower(basePower);
//		while (gyroValue < deciDegreesToTurn)
//		{
//			gyroValue = SensorValue[gyro];
//			delay(30);
//		}
//	}
//	setLeftDriveTrainPower( 0 );
//	setRightDriveTrainPower( 0 );
//}

//Ensures that the flywheel is always begin spun at the speed contained in the global speed variable
task flywheelSpeedUpdate()
{
	while(true)
	{
		setTargetSpeed(controller, isFlywheelOn ? speed : 0);
		update(controller);
		delay(50);
	}
}

//Some functions (notably LCD ones) need to have a delay as they are run to display properly
//	non LCD functions that need a similar delay can also be put in this task
task slowDelayStuff()
{
	string lcdBatteryVoltages, flywheelSpeedDisplay;
	while(true)
	{
		sprintf(lcdBatteryVoltages, "M: %.2f P: %.2f", MainBatteryVoltage(), powerExpanderVoltage(pPowerExp));
		sprintf(flywheelSpeedDisplay, "T: %.2f A: %.2f", controller.targetSpeed, getMeasuredSpeed(controller));
		clearLCDLine(0);
		clearLCDLine(1);
		displayLCDString(0,0,lcdBatteryVoltages);
		displayLCDString(1,0,flywheelSpeedDisplay);
		delay(300);
	}
}

//Flywheel Speed Increment inputs are non-idempotent, so there needs to be a delay
//	to avoid accidental extra presses because the program can loop through a
//	while(true) loop faster than a human can react
task flywheelSpeedFromJoystick()
{
	int lastSpeedFromJoystickTime = nPgmTime;
	while(true)
	{
		if( vexRT[Btn8R] ) isFlywheelOn = true;
		else if( vexRT[Btn8L] ) isFlywheelOn = false;

		bool up = (bool)vexRT[Btn8U];
		bool down = (bool)vexRT[Btn8D];
		if( (up || down) && nPgmTime - lastSpeedFromJoystickTime > 300 )
		{
			float delta = up ? 0.5 : -0.5;
			speed = bound( speed + delta, 8, 16 );
			lastSpeedFromJoystickTime = nPgmTime;
		}

		delay(15);
	}
}

////In the match autonomous, the balls should only be fired if the speed of the flywheel
////	is close enough to the target speed of the flywheel
//void intakeIfRightSpeed()
//{
//	if(abs(speed - controller.measuredSpeed) < 0.3)
//	{
//		//motor[chainIntake] = 127;
//		//motor[bandIntake] = 127;
//	}
//	else
//	{
//		//motor[chainIntake] = 0;
//		//motor[bandIntake] = 0;
//	}
//}

////////////////
////Autonomous//
////////////////

task autonomous()
{
	//if(SensorValue[autoMode] == 0)
	//{
	//	int startTime = nPgmTime;
	//	startTask(flywheelSpeedUpdate); //Starts the Flywheel at this speed
	//	speed = 9.8;
	//	while(true){
	//		intakeIfRightSpeed();
	//		//startTime = nPgmTime;
	//	}
	//	//driveADistance(80);

	//}
	//else
	//{
	//	startTask(flywheelSpeedUpdate);
	//	speed = 8.3; //Have flywheel at medium speed(for skills, shooting at close goal)
	//	//motor[chainIntake] = 127;//Intake all the time cuz there is no time to wait
	//	//motor[bandIntake] = 127;
	//	delay(32000);//this will be changed when we learn how long it takes to shoot 32 balls
	//	speed = 0; //Save motor power
	//	//motor[chainIntake] = 0;
	//	//motor[bandIntake] = 0;
	//	turnaDistance(-620);
	//	driveADistance(100);
	//	turnaDistance(400);
	//	speed = 8.3;
	//	//motor[chainIntake] = 127;
	//	//motor[bandIntake] = 127;
	//}
}

////////////////
//User Control//
////////////////

task usercontrol()
{
	startTask(flywheelSpeedUpdate);
	startTask(flywheelSpeedFromJoystick);
	startTask(slowDelayStuff);

	while(true){

		//speed = bound(speed,0,11); //Ensure speed is legal

		////LEDs
		//if(speed <= 3.3){SensorValue[redLED] = 1;SensorValue[yellowLED] = 0;SensorValue[greenLED] = 0;}
		//else if(speed <= 6.6){SensorValue[redLED] = 0;SensorValue[yellowLED] = 1;SensorValue[greenLED] = 0;}
		//else{SensorValue[redLED] = 0;SensorValue[yellowLED] = 0;SensorValue[greenLED] = 1;}

		//Band Intake Control
		//if(vexRT[Btn6U]){motor[intakeBand] = 127;} //right shoulder button controls intakes together
		//else if(vexRT[Btn6D]){motor[intakeBand] = -127;}
		//else {motor[intakeBand] = 0;}

		motor[intakeBand] = buttonsToPower(Btn6D, Btn6U);

		//Chain Intake Control
		//if(vexRT[Btn5U]){motor[intakeChain] = 127;} //right shoulder button controls intakes together
		//else if(vexRT[Btn5D]){motor[intakeChain] = -127;}
		//else {motor[intakeChain] = 0;}

		motor[intakeChain] = buttonsToPower(Btn5D, Btn5U);

		//Drive Train
		motor[leftOneYThree] = vexRT[Ch3];
		motor[leftTwo] = vexRT[Ch3];
		motor[rightOneYThree] = vexRT[Ch2];
		motor[rightTwo] = vexRT[Ch2];

		//if(vexRT[Btn8U])
		//{
		//	motor[flyOneYThree] = 127;
		//	motor[flyTwo] = 127;
		//	motor[flyFour] = 127;
		//}
		//if(vexRT[Btn8D])
		//{
		//	motor[flyOneYThree] = 0;
		//	motor[flyTwo] = 0;
		//	motor[flyFour] = 0;
		//}


		//Set Flywheel Speed to Presets
		//if(vexRT[Btn7D]){speed = 0;}
		//if(vexRT[Btn7L]){speed = 5.5;}
		//if(vexRT[Btn7U]){speed = 7.5;}
		//if(vexRT[Btn7R]){speed = 11;}
		//if(vexRT[Btn6U]){speed = 9.5;}
		//if(vexRT[Btn6D]){speed = 8.3;}

		delay(15);
	}
}
