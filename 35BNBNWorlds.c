#pragma config(UserModel, "C:/Users/rstudent/code/robot-configs/35B.c")
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)//Platform Type
#pragma competitionControl(Competition) //This is a Competition Template
#pragma autonomousDuration(15) //15 second autonomous mode
#pragma userControlDuration(105) //1:45 driver control mode
#include "Vex_Competition_Includes.c" //Uses Vex stuff
#define POWER_EXPANDER_A1
#include <CKFlywheelSpeedController.h>

////////////////////////////////
//Global Variable Declarations//
////////////////////////////////

float speed = 0; //Speed of the output shaft of Flywheel motors in radians per second
bool isFlywheelOn = false;
FlywheelSpeedController controller;

/////////////////////////////////////////////////////////
//Pre-Autonomous Functions - Initializes most variables//
/////////////////////////////////////////////////////////

void pre_auton()
{
	bStopTasksBetweenModes = true;
	bLCDBacklight = true;
	clearLCDLine(0);
	clearLCDLine(1);

	tMotor motorPorts[] = { flyFour, flyOneYThree, flyTwo };
	FlywheelSpeedControllerInit( controller, 2.0, 0.02, 0.0, 1.2889, 0.0925, motorPorts, 3, M393HighSpeed );

	speed = 0;
	nMotorEncoder[flyFour] = 0;
	nMotorEncoder[rightOneYThree] = 0;
	nMotorEncoder[leftOneYThree] = 0;

	//Completely clear out any previous sensor readings by setting the port to "sensorNone"
	SensorType[gyro] = sensorNone;
	delay(1000);
	//Reconfigure Analog Port as a Gyro sensor and allow time for ROBOTC to calibrate it
	SensorType[gyro] = sensorGyro;
	delay(2000);

}

//////////////////////////////////////////////////////////
//Define Functions Needed for Operator Control and Auton//
//////////////////////////////////////////////////////////

//Ensures that the flywheel is always begin spun at the speed contained in the global speed variable
task flywheelSpeedUpdate()
{
	while(true)
	{
		setTargetSpeed(controller, isFlywheelOn ? speed : 0);
		update(controller);
		delay(30);
	}
}

//Some functions (notably LCD ones) need to have a delay as they are run to display properly
//	non LCD functions that need a similar delay can also be put in this task
task slowDelayStuff()
{
	string lcdBatteryVoltages, flywheelSpeedDisplay;
	while(true)
	{
		sprintf(lcdBatteryVoltages, "M: %.2f P: %.2f", MainBatteryVoltage(), powerExpanderVoltage(pPowerExp));
		sprintf(flywheelSpeedDisplay, "T: %.2f A: %.2f", controller.targetSpeed, getMeasuredSpeed(controller));
		clearLCDLine(0);
		clearLCDLine(1);
		displayLCDString(0,0,lcdBatteryVoltages);
		displayLCDString(1,0,flywheelSpeedDisplay);
		delay(300);
	}
}

//Flywheel Speed Increment inputs are non-idempotent, so there needs to be a delay
//	to avoid accidental extra presses because the program can loop through a
//	while(true) loop faster than a human can react
task flywheelSpeedFromJoystick()
{
	int lastSpeedFromJoystickTime = nPgmTime;
	while(true)
	{
		if( vexRT[Btn8R] ) isFlywheelOn = true;
		else if( vexRT[Btn8L] ) isFlywheelOn = false;

		bool up = (bool)vexRT[Btn8U];
		bool down = (bool)vexRT[Btn8D];
		if( (up || down) && nPgmTime - lastSpeedFromJoystickTime > 300 )
		{
			float delta = up ? 0.5 : -0.5;
			speed = bound( speed + delta, 8, 16 );
			lastSpeedFromJoystickTime = nPgmTime;
		}

		delay(15);
	}
}

////In the match autonomous, the balls should only be fired if the speed of the flywheel
////	is close enough to the target speed of the flywheel
void intakeIfRightSpeed()
{
	if(abs(speed - getMeasuredSpeed(controller)) < 0.3)
	{
		motor[intakeBand] = 127;
		motor[intakeChain] = 127;
	}
	else
	{
		motor[intakeChain] = 0;
		motor[intakeBand] = 0;
	}
}
void setRightDrive (int p)
{
	motor[rightOneYThree] = p;
	motor[rightTwo] = p;
}
void setLeftDrive (int p)
{
	motor[leftOneYThree] = p;
	motor[leftTwo] = p;
}
//Drives a given number of inches
void driveADistance(float inchesToDrive)
{
	float ticksToDrive = 360 * inchesToDrive / (4 * PI);
	nMotorEncoder[rightOneYThree] = 0;
	nMotorEncoder[leftOneYThree] = 0;
	int rightEncoderCount = 0;
	int leftEncoderCount = 0;
	bool rightIsDone = false;
	bool leftIsDone = false;
	float Kp = 7.0;
	SensorValue[gyro] = 0;
	int gyroReading = SensorValue[gyro];
	while (!rightIsDone || !leftIsDone)
	{
		rightIsDone = rightEncoderCount>=ticksToDrive;
		leftIsDone = leftEncoderCount>=ticksToDrive;
		gyroReading = SensorValue[gyro];
		rightEncoderCount += nMotorEncoder[rightOneYThree];
		nMotorEncoder[rightOneYThree] = 0;
		leftEncoderCount += nMotorEncoder[leftOneYThree];
		nMotorEncoder[leftOneYThree] = 0;
		//float error = rightEncoderCount - leftEncoderCount;
		float error = gyroReading;
		setRightDrive(rightIsDone ? 0 : 127 - Kp*error);
		setLeftDrive(leftIsDone ? 0 : 127 + Kp*error);
	}
}
void turnRight(float degreesToTurn)
{
	int deciDegreesToTurn = degreesToTurn * 10;
	SensorValue[gyro] = 0;
	int gyroReading = -SensorValue[gyro];
	while (gyroReading < deciDegreesToTurn)
	{
		gyroReading = -SensorValue[gyro];
		setRightDrive(-50);
		setLeftDrive(50);
	}
	setRightDrive(0);
	setLeftDrive(0);
}

void turnLeft(float degreesToTurn)
{
	int deciDegreesToTurn = degreesToTurn * 70/9;
	SensorValue[gyro] = 0;
	int gyroReading = SensorValue[gyro];
	while (gyroReading < deciDegreesToTurn)
	{
		gyroReading = SensorValue[gyro];
		setRightDrive(50);
		setLeftDrive(-50);
	}
	setRightDrive(0);
	setLeftDrive(0);
}
////////////////
////Autonomous//
////////////////

task autonomous()
{
	driveADistance(60);
	turnLeft(90);
	delay(5000);
	turnRight(90);
	if(SensorValue[autoMode] == 0)
	{
		int startTime = nPgmTime;
		startTask(flywheelSpeedUpdate); //Starts the Flywheel at this speed
		//Match Auto
		speed = 16;
		while(true){
			intakeIfRightSpeed();
		}
	}
	else
	{
		startTask(flywheelSpeedUpdate);
		//Prog Skills
	}
}

////////////////
//User Control//
////////////////

task usercontrol()
{
	startTask(flywheelSpeedUpdate);
	startTask(flywheelSpeedFromJoystick);
	startTask(slowDelayStuff);

	while(true){

		////LEDs
		if(speed <= 11){SensorValue[redLED] = 1;SensorValue[yellowLED] = 0;SensorValue[greenLED] = 0;}
		else if(speed <= 14){SensorValue[redLED] = 0;SensorValue[yellowLED] = 1;SensorValue[greenLED] = 0;}
		else{SensorValue[redLED] = 0;SensorValue[yellowLED] = 0;SensorValue[greenLED] = 1;}

		motor[intakeBand] = buttonsToPower(Btn6D, Btn6U);
		motor[intakeChain] = buttonsToPower(Btn5D, Btn5U);

		//Drive Train
		motor[leftOneYThree] = vexRT[Ch3];
		motor[leftTwo] = vexRT[Ch3];
		motor[rightOneYThree] = vexRT[Ch2];
		motor[rightTwo] = vexRT[Ch2];


		//Set Flywheel Speed to Presets
		if(vexRT[Btn7D]){speed = 10;}
		if(vexRT[Btn7L]){speed = 12;}
		if(vexRT[Btn7U]){speed = 14;}
		if(vexRT[Btn7R]){speed = 16;}

		delay(15);
	}
}

// SUCK CHOOOOODEE!!!!
// ^^ That should fix it.
