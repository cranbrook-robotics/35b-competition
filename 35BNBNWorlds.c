#pragma config(UserModel, "C:/Users/rstudent/code/robot-configs/35B.c")
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)//Platform Type
#pragma competitionControl(Competition) //This is a Competition Template
#pragma autonomousDuration(15) //15 second autonomous mode
#pragma userControlDuration(105) //1:45 driver control mode
#include "Vex_Competition_Includes.c" //Uses Vex stuff
#define POWER_EXPANDER_A1
#include <CKFlywheelSpeedController.h>

////////////////////////////////
//Global Variable Declarations//
////////////////////////////////
//Swag
float speed = 0; //Speed of the output shaft of Flywheel motors in radians per second
bool isFlywheelOn = false;
FlywheelSpeedController controller;

#define A 1.2889
#define B 0.0925
#define Kq 0.1
#define Ki 0.02
#define Kd 0.0


/////////////////////////////////////////////////////////
//Pre-Autonomous Functions - Initializes most variables//
/////////////////////////////////////////////////////////
void resetDriveEncoders()
{
	nMotorEncoder[rightOneYThree] = 0;
	nMotorEncoder[leftOneYThree] = 0;

}
void pre_auton()
{
	bStopTasksBetweenModes = true;
	bLCDBacklight = true;
	clearLCDLine(0);
	clearLCDLine(1);

	tMotor motorPorts[] = { flyFour, flyOneYThree, flyTwo };
	FlywheelSpeedControllerInit( controller, Kq, Ki, Kd, A, B, motorPorts, 3, M393HighSpeed );

	speed = 0;
	resetDriveEncoders();
	nMotorEncoder[flyFour] = 0;

	//Completely clear out any previous sensor readings by setting the port to "sensorNone"
	SensorType[gyro] = sensorNone;
	delay(1000);
	//Reconfigure Analog Port as a Gyro sensor and allow time for ROBOTC to calibrate it
	SensorType[gyro] = sensorGyro;
	delay(2000);

}

//////////////////////////////////////////////////////////
//Define Functions Needed for Operator Control and Auton//
//////////////////////////////////////////////////////////

//Ensures that the flywheel is always begin spun at the speed contained in the global speed variable
task flywheelSpeedUpdate()
{
	while(true)
	{
		setTargetSpeed(controller, isFlywheelOn ? speed : 0);
		update(controller);
		delay(30);
	}
}

//Some functions (notably LCD ones) need to have a delay as they are run to display properly
//	non LCD functions that need a similar delay can also be put in this task
task slowDelayStuff()
{
	string lcdBatteryVoltages, flywheelSpeedDisplay;
	while(true)
	{
		sprintf(lcdBatteryVoltages, "M: %.2f P: %.2f", MainBatteryVoltage(), powerExpanderVoltage(pPowerExp));
		sprintf(flywheelSpeedDisplay, "T: %.2f A: %.2f", controller.targetSpeed, getMeasuredSpeed(controller));
		clearLCDLine(0);
		clearLCDLine(1);
		displayLCDString(0,0,lcdBatteryVoltages);
		displayLCDString(1,0,flywheelSpeedDisplay);
		delay(300);
	}
}

//Flywheel Speed Increment inputs are non-idempotent, so there needs to be a delay
//	to avoid accidental extra presses because the program can loop through a
//	while(true) loop faster than a human can react
task flywheelSpeedFromJoystick()
{
	int lastSpeedFromJoystickTime = nPgmTime;
	while(true)
	{
		if( vexRT[Btn8R] ) isFlywheelOn = true;
		else if( vexRT[Btn8L] ) isFlywheelOn = false;

		bool up = (bool)vexRT[Btn8U];
		bool down = (bool)vexRT[Btn8D];
		if( (up || down) && nPgmTime - lastSpeedFromJoystickTime > 300 )
		{
			float delta = up ? 0.5 : -0.5;
			speed = bound( speed + delta, 8, 16 );
			lastSpeedFromJoystickTime = nPgmTime;
		}

		delay(15);
	}
}
void intake(int p)
{
	motor[intakeBand] = p;
	motor[intakeChain] = p;
}
////In the match autonomous, the balls should only be fired if the speed of the flywheel
////	is close enough to the target speed of the flywheel
void intakeIfRightSpeed(int time)
{
	int startTime = nPgmTime;
	while (nPgmTime < startTime + time)
	{
		if(abs(speed - getMeasuredSpeed(controller)) < 0.3)
		{
			intake(127);
		}
		else
		{
			intake(0);
		}
	}
	intake(0);
}
void setRightDrive (int p)
{
	motor[rightOneYThree] = p;
	motor[rightTwo] = p;
}
void setLeftDrive (int p)
{
	motor[leftOneYThree] = p;
	motor[leftTwo] = p;
}
//Drives a given number of inches
void driveADistance(float inchesToDrive)
{
	float ticksToDrive = 360 * inchesToDrive / (4 * PI);
	nMotorEncoder[rightOneYThree] = 0;
	nMotorEncoder[leftOneYThree] = 0;
	int rightEncoderCount = 0, leftEncoderCount = 0;
	bool rightIsDone = false, leftIsDone = false;
	float Kp = 0.5;
	SensorValue[gyro] = 0;
	int gyroReading = SensorValue[gyro];
	while (!rightIsDone || !leftIsDone)
	{
		rightIsDone = rightEncoderCount>=ticksToDrive;
		leftIsDone = leftEncoderCount>=ticksToDrive;
		gyroReading = SensorValue[gyro];
		rightEncoderCount += nMotorEncoder[rightOneYThree];
		leftEncoderCount += nMotorEncoder[leftOneYThree];
		resetDriveEncoders();
		//float error = rightEncoderCount - leftEncoderCount;
		float error = gyroReading;
		setRightDrive(rightIsDone ? 0 : 75 - Kp*error);
		setLeftDrive(leftIsDone ? 0 : 75 + Kp*error);
	}
}
void turnRight(float degreesToTurn)
{
	int deciDegreesToTurn = degreesToTurn * 10;
	SensorValue[gyro] = 0;
	int gyroReading = -SensorValue[gyro];
	while (gyroReading < deciDegreesToTurn)
	{
		gyroReading = -SensorValue[gyro];
		setRightDrive(-50);
		setLeftDrive(50);
	}
	setRightDrive(0);
	setLeftDrive(0);
}

void turnLeft(float degreesToTurn)
{
	int deciDegreesToTurn = degreesToTurn * 10;
	SensorValue[gyro] = 0;
	int gyroReading = SensorValue[gyro];
	while (gyroReading < deciDegreesToTurn)
	{
		gyroReading = SensorValue[gyro];
		setRightDrive(50);
		setLeftDrive(-50);
	}
	setRightDrive(0);
	setLeftDrive(0);
}

void redNet()
{
	driveADistance(18);
	turnLeft(45);
	intake(127);
	driveADistance(36);
	intake(-127);
	delay(100);
	intake(0);
	speed = 12;
	isFlywheelOn = true;
	startTask(flywheelSpeedUpdate);
	intakeIfRightSpeed(6000);
	speed = 0;
	intake(127);
	driveADistance(36);
	intake(0);
	turnRight(5);
	isFlywheelOn = true;
	speed = 10.5;
	intakeIfRightSpeed(10000);
}
void blueNet()
{
	driveADistance(18);
	turnRight(36);
	intake(127);
	driveADistance(36);
	intake(-127);
	delay(120);
	intake(0);
	speed = 12;
	isFlywheelOn = true;
	startTask(flywheelSpeedUpdate);
	intakeIfRightSpeed(6000);
	speed = 0;
	intake(127);
	driveADistance(36);
	intake(0);
	turnLeft(1);
	isFlywheelOn = true;
	speed = 10.5;
	intakeIfRightSpeed(10000);
}
void progSkillsCross()
{
	turnRight(70);
	driveADistance(96);
	turnLeft(70);

}
////////////////
////Autonomous//
////////////////

task autonomous()
{
	//redNet();
	//progSkillsCross();
	blueNet();
}

////////////////
//User Control//
////////////////

task usercontrol()
{
	startTask(flywheelSpeedUpdate);
	startTask(flywheelSpeedFromJoystick);
	startTask(slowDelayStuff);

	while(true){

		////LEDs
		if(speed <= 11){SensorValue[redLED] = 1;SensorValue[yellowLED] = 0;SensorValue[greenLED] = 0;}
		SensorValue[redLED] = (speed <= 11 ? 1 : 0);
		SensorValue[greenLED] = (speed > 14 ? 1 : 0);
		SensorValue[yellowLED] = (SensorValue[redLED] + SensorValue[greenLED] == 0 ? 1 : 0);

		motor[intakeBand] = buttonsToPower(Btn6DXmtr2, Btn6UXmtr2);
		motor[intakeChain] = buttonsToPower(Btn5DXmtr2, Btn5UXmtr2);

		//Drive Train
		setLeftDrive(vexRT[Ch3]);
		setRightDrive(vexRT[Ch2]);


		//Set Flywheel Speed to Presets
		if(vexRT[Btn7L]){speed = 10.5;}
		if(vexRT[Btn7U]){speed = 12;}
		if(vexRT[Btn7R]){speed = 16;}

		delay(15);
	}
}
